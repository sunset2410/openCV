#define MAX_NODE 400007
#define MAX_TABLE 50007
#define NULL 0
using namespace std;

// begin linklist
struct Node 
{
	int pos;
	Node* next;
	Node* pre;
};

Node poolNode[MAX_NODE];
int countNode;

char origin_str[50007];
int _N;



Node* newNode(int value  = -1)
{
	Node* temp = &poolNode[countNode];
	temp->pos = value;
	temp->next = temp->pre = NULL;
	countNode++;
	return temp;
}

void linkNode(Node* front, Node* back)
{
	front->next = back;
	back->pre = front;
}

void insertNode(Node* front, Node* n, Node* back)
{
	linkNode(front, n);
	linkNode(n, back);
}

void removeNode(Node* n)
{
	linkNode(n->pre, n->next);
}


bool recheck(int pos, char str[])
{
	if (origin_str[pos] != str[0]) return false;
	if (origin_str[pos + 1] != str[1]) return false;
	if (origin_str[pos + 2] != str[2]) return false;
	return true;
}

struct List
{
public:
	Node* head;
	Node* tail;
	void init()
	{
		head = newNode(-1);
		tail = newNode(1000000);
		linkNode(head, tail);
	}

	// insert vao theo thu tu tang dan
	void insert(int value)  // insert theo thu tu tang dan
	{
		Node* n = newNode(value);
		Node* temp = head;
		while (temp != tail)
		{
			if (temp->pos > value)
			{
				// insert vao truoc temp
				insertNode(temp->pre, n, temp);
				return;
			}
			temp = temp->next;
		}
		// khong tim ra vi tri  co gia tri  > value => insert vao cuoi
		insertNode(tail->pre, n, tail);
	}


	// remove gia tri
	void remove(int value,char  tag[])
	{
		Node* temp = head->next;
		while (temp != tail)
		{
			if (temp->pos == value && recheck(value,tag))
			{
				// remove temp
				linkNode(temp->pre, temp->next);
				return;
			}
			temp = temp->next;
		}
	}

};

// end linklist

List hashTable[MAX_TABLE];

void copyStr(char* s, char* d)
{
	while (*s != '\0')
	{
		*d = *s;
		d++;
		s++;
	}
	*d = *s;
}


bool compareStr(char* s1, char* s2)
{
	while (*s1 != '\0')
	{
		if (*s1 != *s2) return false;
		s1++;
		s2++;
	}

	if (*s1 != *s2) return false;
	return true;
}



typedef unsigned long ul;

unsigned long hashvalue(const char *str)
{
	unsigned long hash = 5381;
	int c;

	while (c = *str++)
	{
		hash = (((hash << 5) + hash) + c) % MAX_TABLE;
	}

	return hash % MAX_TABLE;
}

char tag[4];
void addTag(int n, char string[])
{
	if (n < 3) return;

	for (int i = 0; i <= n - 3; i++)  // i la vi tri dau tien cua tag 3 ki tu
	{
		int index = 0;
		for (int j = i; j <= i + 2; j++)
		{
			tag[index] = origin_str[j];
			index++;
		}
		tag[index] = '\0';

		//---------- add tag------------//
		// insert vi tri dau tien cua tag vao hash table vector cos sap xep tu be toi lon
		ul hv = hashvalue(tag);
		hashTable[hv].insert(i);
	}
}


void init(int N, char init_string[])
{
	_N = N;
	copyStr(init_string, origin_str);

	for (int i = 0; i < MAX_TABLE; i++)
	{
		hashTable[i].init();
	}


	// add tag
	addTag(_N, origin_str);
}



// convert string A to string B
// length cua A va B deu bang 3
// return  so sub string da convert
int change(char string_A[], char string_B[])
{
	int count = 0;
	
	ul index = hashvalue(string_A);
	List list = hashTable[index];

	Node* temp = list.head->next;

	int pre = 0;
	while(temp!= list.tail) // for  het cac vi tri de thay string a thanh b
	{
		int index = temp->pos;
		
		if (index < pre)
		{
			temp = temp->next;
			continue;
		}
			

		if (recheck(index, string_A) == false) 
		{
			temp = temp->next;
			continue;
		}

		// doi string a o vi tri index thanh string b
		// xoa c√°c hash tag cu
		for (int i = index - 2; i <= index + 2; i++)
		{
			if (i < 0 || i > _N - 3)
				continue;

			char tag[4];
			tag[0] = origin_str[i];
			tag[1] = origin_str[i + 1];
			tag[2] = origin_str[i + 2];
			tag[3] = '\0';

			 // xoa tag
			ul pos = hashvalue(tag);
			hashTable[pos].remove(i, tag);
		}


		// thay string 
		origin_str[index] = string_B[0];
		origin_str[index + 1] = string_B[1];
		origin_str[index + 2] = string_B[2];

		// them cac hash tag moi
		for (int i = index - 2; i <= index + 2; i++)
		{
			if (i < 0 || i > _N - 3)
				continue;

			char tag[4];
			tag[0] = origin_str[i];
			tag[1] = origin_str[i + 1];
			tag[2] = origin_str[i + 2];
			tag[3] = '\0';

			// them tag
			ul pos = hashvalue(tag);
			hashTable[pos].insert(i);
		}

		// tang pre
		pre = index + 3;

		// dem so tag da bi thay the
		count++;

		temp = temp->next;
	}

	return count;
}

// return final string. only call 1 time  in the end of test case
void result(char ret[])
{
	copyStr(origin_str, ret);
}
